<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TransactionBlockEvent.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenHFT/Chronicle-Decentred</a> &gt; <a href="index.source.html" class="el_package">net.openhft.chronicle.decentred.dto.blockevent</a> &gt; <span class="el_source">TransactionBlockEvent.java</span></div><h1>TransactionBlockEvent.java</h1><pre class="source lang-java linenums">package net.openhft.chronicle.decentred.dto.blockevent;

import net.openhft.chronicle.bytes.Bytes;
import net.openhft.chronicle.bytes.BytesIn;
import net.openhft.chronicle.bytes.BytesOut;
import net.openhft.chronicle.core.Jvm;
import net.openhft.chronicle.decentred.dto.base.SignedMessage;
import net.openhft.chronicle.decentred.dto.base.TransientFieldHandler;
import net.openhft.chronicle.decentred.dto.base.VanillaSignedMessage;
import net.openhft.chronicle.decentred.dto.base.trait.HasChainAddress;
import net.openhft.chronicle.decentred.dto.base.trait.HasDtoParser;
import net.openhft.chronicle.decentred.util.AddressLongConverter;
import net.openhft.chronicle.decentred.util.DtoParser;
import net.openhft.chronicle.wire.AbstractBytesMarshallable;
import net.openhft.chronicle.wire.LongConversion;
import net.openhft.chronicle.wire.WireIn;
import net.openhft.chronicle.wire.WireOut;
import org.jetbrains.annotations.NotNull;

import java.util.function.Consumer;

/**
 * An TransactionBlockEvent is a &lt;em&gt;chain event&lt;/em&gt; that holds the transactions that is in a block.
 *
 */
public final class TransactionBlockEvent&lt;T&gt; extends VanillaSignedMessage&lt;TransactionBlockEvent&lt;T&gt;&gt; implements
        HasChainAddress&lt;TransactionBlockEvent&lt;T&gt;&gt;,
        HasDtoParser&lt;TransactionBlockEvent&lt;T&gt;, T&gt; {

<span class="fc" id="L30">    private static long INITIAL_TRANSACTION_CAPACITY_BYTES = 4L &lt;&lt; 10;</span>

    @LongConversion(AddressLongConverter.class)
    private long chainAddress;

    private transient DtoParser&lt;T&gt; dtoParser;
    private transient final Bytes transactions;

<span class="fc" id="L38">    public TransactionBlockEvent() {</span>
<span class="fc" id="L39">        transactions = Bytes.allocateElasticDirect(INITIAL_TRANSACTION_CAPACITY_BYTES);</span>
<span class="fc" id="L40">    }</span>

    @Override
    public DtoParser&lt;T&gt; dtoParser() {
<span class="fc" id="L44">        return dtoParser;</span>
    }

    @Override
    public TransactionBlockEvent&lt;T&gt; dtoParser(@NotNull DtoParser&lt;T&gt; dtoParser) {
<span class="fc" id="L49">        this.dtoParser = dtoParser;</span>
<span class="fc" id="L50">        return this;</span>
    }

    /**
     * Replays all transactions on the provided message handler.
     * &lt;p&gt;
     * Note: Messages used when invoking the provided message handler may be
     * reused. If messages are saved by the message handler, internal
     * copies must be made to ensure proper functionality.
     *
     * @param messageHandler message handler to replay messages on
     *
     * @throws IllegalStateException if this message has
     * not been signed before this method is called.
     */
    public void replay(@NotNull T messageHandler) {
<span class="fc" id="L66">        replay(b -&gt; dtoParser.parseOne(b, messageHandler));</span>
<span class="fc" id="L67">    }</span>

    /**
     * Replays all transactions on the provided consumer.
     *
     * @param consumer to invoke on each message
     *
     * @throws IllegalStateException if this message has
     * not been signed before this method is called.
     */
    private void replay(@NotNull Consumer&lt;Bytes&gt; consumer) {
<span class="fc" id="L78">        assertSigned();</span>
<span class="fc" id="L79">        transactions.readPosition(0);</span>
<span class="fc" id="L80">        final long originalLimit = transactions.readLimit();</span>
        try {
<span class="fc bfc" id="L82" title="All 2 branches covered.">            while (!transactions.isEmpty()) {</span>
<span class="fc" id="L83">                final long position = transactions.readPosition();</span>
<span class="fc" id="L84">                final long length = transactions.readUnsignedInt(position);</span>
<span class="fc" id="L85">                transactions.readLimit(position + length);</span>
                try {
<span class="fc" id="L87">                    consumer.accept(transactions);  // The consumer may or may not affect the read position</span>
<span class="nc" id="L88">                } catch (Exception e) {</span>
<span class="nc" id="L89">                    Jvm.warn().on(getClass(), &quot;Error processing transaction event &quot;, e);</span>
<span class="fc" id="L90">                }</span>
             //   System.out.format(&quot;txid: %d, originalLimit: %d, length: %d, position: %d, readPosition:%d%n&quot;, System.identityHashCode(transactions), originalLimit, length, position, transactions.readPosition());

<span class="fc" id="L93">                transactions.readLimit(originalLimit);</span>
<span class="fc" id="L94">                transactions.readPosition(position + length);</span>
<span class="fc" id="L95">            }</span>
        } finally {
<span class="fc" id="L97">            transactions.readLimit(originalLimit);</span>
        }
<span class="fc" id="L99">    }</span>

    /**
     * Adds a transaction to this message.
     *
     * @param message to add
     * @return this instance
     */
    public TransactionBlockEvent addTransaction(@NotNull SignedMessage message) {
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">        if (!message.signed()) {</span>
<span class="nc" id="L109">            throw new IllegalArgumentException(</span>
<span class="nc" id="L110">                String.format(&quot;The message of type %s, protocol %d, messageType %d has not been signed.&quot;, message.getClass().getSimpleName(), message.protocol(),  message.messageType())</span>
            );
        }
<span class="fc" id="L113">        message.writeMarshallable(transactions);</span>
<span class="fc" id="L114">        return this;</span>
    }

    /**
     * Returns if this message's transaction queue is empty (of un-replayed transactions).
     * &lt;p&gt;
     *  If all transactions are replayed, the method returns {@code true},
     *  otherwise it returns {@code false}
     *
     * @return if this message's transaction queue is empty (of un-replayed transactions)
     */
    public boolean isEmpty() {
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">        return transactions.readRemaining() == 0;</span>
    }

    @Override
    public long chainAddress() {
<span class="fc" id="L131">        return chainAddress;</span>
    }

    @Override
    public TransactionBlockEvent&lt;T&gt; chainAddress(long chainAddress) {
<span class="fc" id="L136">        assertNotSigned();</span>
<span class="fc" id="L137">        this.chainAddress = chainAddress;</span>
<span class="fc" id="L138">        return this;</span>
    }

// Handling of transient fields

<span class="fc" id="L143">    private final transient TransientFieldHandler&lt;TransactionBlockEvent&lt;T&gt;&gt; transientFieldHandler = new CustomTransientFieldHandler();</span>

    @Override
    public TransientFieldHandler&lt;TransactionBlockEvent&lt;T&gt;&gt; transientFieldHandler() {
<span class="fc" id="L147">        return transientFieldHandler;</span>
    }

<span class="fc" id="L150">private final class CustomTransientFieldHandler implements TransientFieldHandler&lt;TransactionBlockEvent&lt;T&gt;&gt; {</span>

        @Override
        public void reset(TransactionBlockEvent&lt;T&gt; original) {
<span class="fc" id="L154">            original.dtoParser = null;</span>
<span class="fc" id="L155">            original.transactions.clear();</span>
<span class="fc" id="L156">        }</span>

        @Override
        public void copyNonMarshalled(@NotNull TransactionBlockEvent&lt;T&gt; original, @NotNull TransactionBlockEvent&lt;T&gt; target) {
<span class="fc" id="L160">            target.dtoParser(original.dtoParser());</span>
<span class="fc" id="L161">        }</span>

        @Override
        public void writeMarshallable(@NotNull TransactionBlockEvent&lt;T&gt; original, @NotNull WireOut wire) {
<span class="fc" id="L165">                wire.write(&quot;transactions&quot;).sequence(out -&gt;</span>
<span class="fc" id="L166">                    original.replay(b -&gt; out.object(original.dtoParser.parseOne(b)))</span>
                );
<span class="fc" id="L168">        }</span>

        @Override
        public void readMarshallable(@NotNull TransactionBlockEvent&lt;T&gt; original, @NotNull WireIn wire) {
<span class="nc" id="L172">            wire.read(&quot;transactions&quot;).sequence(original, (tbe, in) -&gt; {</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">                while (in.hasNextSequenceItem()) {</span>
<span class="nc" id="L174">                    final WireIn wireIn = in.wireIn();</span>
<span class="nc" id="L175">                    final SignedMessage m = in.typedMarshallable();</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">                    if (m instanceof AbstractBytesMarshallable) {</span>
<span class="nc" id="L177">                        ((AbstractBytesMarshallable) m).readMarshallable(wireIn);</span>
                    }
<span class="nc" id="L179">                    original.addTransaction(m);</span>
<span class="nc" id="L180">                }</span>
<span class="nc" id="L181">            });</span>
<span class="nc" id="L182">        }</span>

        @Override
        public void writeMarshallableInternal(@NotNull TransactionBlockEvent&lt;T&gt; original, @NotNull BytesOut bytes) {
<span class="fc" id="L186">            bytes.write(original.transactions);</span>
<span class="fc" id="L187">        }</span>

        @Override
        public void readMarshallable(@NotNull TransactionBlockEvent&lt;T&gt; original, @NotNull BytesIn bytes) {
<span class="fc" id="L191">            original.transactions.write(bytes);</span>
<span class="fc" id="L192">        }</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>